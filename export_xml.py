#!/usr/bin/env python
# coding: utf-8
from Utils import EDITION

# å¤–éƒ¨å‚æ•°è¾“å…¥

import argparse
import sys
import os

ap = argparse.ArgumentParser(description="Export Premiere Pro XML from timeline file.")
ap.add_argument("-l", "--TimeLine", help='Timeline (and break_point with same name), which was generated by replay_generator.py.',type=str)
ap.add_argument("-d", "--MediaObjDefine", help='Definition of the media elements, using real python code.',type=str)
ap.add_argument("-t", "--CharacterTable", help='This program do not need CharacterTable.',type=str)
ap.add_argument("-o", "--OutputPath", help='Choose the destination directory to save the project timeline and break_point file.',type=str,default=None)
# å¢åŠ ä¸€ä¸ªï¼Œè¯»å–æ—¶é—´è½´å’Œæ–­ç‚¹æ–‡ä»¶çš„é€‰é¡¹ï¼
ap.add_argument("-F", "--FramePerSecond", help='Set the FPS of display, default is 30 fps, larger than this may cause lag.',type=int,default=30)
ap.add_argument("-W", "--Width", help='Set the resolution of display, default is 1920, larger than this may cause lag.',type=int,default=1920)
ap.add_argument("-H", "--Height", help='Set the resolution of display, default is 1080, larger than this may cause lag.',type=int,default=1080)
ap.add_argument("-Z", "--Zorder", help='Set the display order of layers, not recommended to change the values unless necessary!',type=str,
                default='BG3,BG2,BG1,Am3,Am2,Am1,AmS,Bb,BbS')
args = ap.parse_args()

media_obj = args.MediaObjDefine #åª’ä½“å¯¹è±¡å®šä¹‰æ–‡ä»¶çš„è·¯å¾„
char_tab = args.CharacterTable #è§’è‰²å’Œåª’ä½“å¯¹è±¡çš„å¯¹åº”å…³ç³»æ–‡ä»¶çš„è·¯å¾„
stdin_log = args.TimeLine #logè·¯å¾„
output_path = args.OutputPath #ä¿å­˜çš„æ—¶é—´è½´ï¼Œæ–­ç‚¹æ–‡ä»¶çš„ç›®å½•

screen_size = (args.Width,args.Height) #æ˜¾ç¤ºçš„åˆ†è¾¨ç‡
frame_rate = args.FramePerSecond #å¸§ç‡ å•ä½fps
zorder = args.Zorder.split(',') #æ¸²æŸ“å›¾å±‚é¡ºåº

try:
    for path in [stdin_log,media_obj]:
        if path is None:
            raise OSError("[31m[ArgumentError]:[0m Missing principal input argument!")
        if os.path.isfile(path) == False:
            raise OSError("[31m[ArgumentError]:[0m Cannot find file "+path)

    if output_path is None:
        pass 
    elif os.path.isdir(output_path) == False:
        try:
            os.makedirs(output_path)
        except Exception:
            raise OSError("[31m[SystemError]:[0m Cannot make directory "+output_path)
    output_path = output_path.replace('\\','/')

    # FPS
    if frame_rate <= 0:
        raise ValueError("[31m[ArgumentError]:[0m "+str(frame_rate))
    elif frame_rate>30:
        print("[33m[warning]:[0m",'FPS is set to '+str(frame_rate)+', which may cause lag in the display!')

    if (screen_size[0]<=0) | (screen_size[1]<=0):
        raise ValueError("[31m[ArgumentError]:[0m "+str(screen_size))
    if screen_size[0]*screen_size[1] > 3e6:
        print("[33m[warning]:[0m",'Resolution is set to more than 3M, which may cause lag in the display!')
except Exception as E:
    print(E)
    sys.exit(1)

# åŒ…å¯¼å…¥

import pandas as pd
import numpy as np
from PIL import Image,ImageFont,ImageDraw
import re
from pygame import mixer
import glob # åŒ¹é…è·¯å¾„
import pickle

from FreePos import Pos,FreePos,PosGrid

# å¼‚å¸¸å®šä¹‰

from Exceptions import MediaError

# æ–‡å­—å¯¹è±¡

outtext_index = 0
outanime_index = 0 
clip_index = 0
file_index = 0

class Text:
    def __init__(self,fontfile='./media/SourceHanSansCN-Regular.otf',fontsize=40,color=(0,0,0,255),line_limit=20,label_color='Lavender'):
        self.color=color
        self.size=fontsize
        self.line_limit = line_limit
        self.fontpath = fontfile
        self.label_color = label_color
    def render(self,tx):
        font_this = ImageFont.truetype(self.fontpath, self.size)
        text_this = Image.new(mode='RGBA',size=(self.size*int(len(tx)*1.5),self.size*2),color=(0,0,0,0)) # ç”»å¸ƒè´ªå©ªä¸º2xé«˜åº¦ï¼Œ1.5*å®½åº¦
        draw_this = ImageDraw.Draw(text_this)
        draw_this.text((0,0),tx,font = font_this,align ="left",fill = self.color)
        return text_this
    def draw(self,text):
        out_text = []
        if ('#' in text) | (text[0]=='^'): #å¦‚æœæœ‰æ‰‹åŠ¨æŒ‡å®šçš„æ¢è¡Œç¬¦
            if text[0]=='^': # å¦‚æœä½¿ç”¨^æŒ‡å®šçš„æ‰‹åŠ¨æ¢è¡Œï¼Œåˆ™å…ˆå»æ‰è¿™ä¸ªå­—ç¬¦ã€‚
                text = text[1:]
            text_line = text.split('#')
            for tx in text_line:
                out_text.append(self.render(tx))
        elif len(text) > self.line_limit: #å¦‚æœæ—¢æ²¡æœ‰ä¸»åŠ¨æŒ‡å®šï¼Œå­—ç¬¦é•¿åº¦ä¹Ÿè¶…é™
            for i in range(0,len(text)//self.line_limit+1):
                out_text.append(self.render(text[i*self.line_limit:(i+1)*self.line_limit]))
        else:
            out_text = [self.render(text)]
        return out_text
    def convert(self):
        pass

class StrokeText(Text):
    def __init__(self,fontfile='./media/SourceHanSansCN-Regular.otf',fontsize=40,color=(0,0,0,255),line_limit=20,edge_color=(255,255,255,255),label_color='Lavender'):
        super().__init__(fontfile=fontfile,fontsize=fontsize,color=color,line_limit=line_limit,label_color=label_color) # ç»§æ‰¿
        self.edge_color=edge_color
    def render(self,tx):
        font_this = ImageFont.truetype(self.fontpath, self.size)
        text_this = Image.new(mode='RGBA',size=(self.size*int(len(tx)*1.5),self.size*2),color=(0,0,0,0)) # ç”»å¸ƒè´ªå©ªä¸º2xé«˜åº¦ï¼Œ1.5*å®½åº¦
        draw_this = ImageDraw.Draw(text_this)
        for pos in [(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)]:
            draw_this.text(pos,tx,font = font_this,align ="left",fill = self.edge_color)
        draw_this.text((1,1),tx,font = font_this,align ="left",fill = self.color)
        return text_this

    # å¯¹è¯æ¡†ã€æ°”æ³¡ã€æ–‡æœ¬æ¡†
class Bubble:
    def __init__(self,filepath=None,Main_Text=Text(),Header_Text=None,pos=(0,0),mt_pos=(0,0),ht_pos=(0,0),ht_target='Name',align='left',line_distance=1.5,label_color='Lavender'):
        global file_index
        # æ”¯æŒæ°”æ³¡å›¾ç¼ºçœ
        if filepath is None or filepath == 'None':
            self.path = None
            self.media = None
            self.size = screen_size
            self.filename = None
        else:
            self.path = reformat_path(filepath)
            self.media = Image.open(filepath).convert('RGBA')
            self.size = self.media.size
            self.filename = self.path.split('/')[-1]
        # pos
        if type(pos) in [Pos,FreePos]:
            self.pos = pos
        else:
            self.pos = Pos(*pos)
        # Text
        self.MainText = Main_Text
        self.mt_pos = mt_pos
        self.Header = Header_Text
        self.ht_pos = ht_pos
        self.target = ht_target
        self.line_distance = line_distance
        self.align = align
        # clip
        self.fileindex = 'BBfile_' + '%d'% file_index
        self.label_color = label_color
        file_index = file_index+1
    # return a canvas
    def draw(self, text, header=''):
        # ç”Ÿæˆæ–‡æœ¬å›¾ç‰‡
        # ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
        canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
        if (self.Header!=None) & (header!=''):    # Header æœ‰å®šä¹‰ï¼Œä¸”è¾“å…¥æ–‡æœ¬ä¸ä¸ºç©º
            ht_text = self.Header.draw(header)[0]
            try:
                p1,p2,p3,p4 = ht_text.getbbox() # å¦‚æœæ˜¯ç©ºå›¾çš„è¯ï¼Œgetbboxè¿”å›Noneï¼Œä¼šå‘ç”ŸTypeError
                canvas.paste(ht_text.crop((p1,p2,p3,p4)),(self.ht_pos[0]+p1,self.ht_pos[1]+p2)) # å…¼å®¹å¾®è½¯é›…é»‘è¿™ç§ï¼Œbboxåˆ°å¤„é£˜çš„å­—ä½“
            except TypeError:
                pass
        x,y = self.mt_pos
        for i,mt_text in enumerate(self.MainText.draw(text)):
            try:
                p1,p2,p3,p4 = mt_text.getbbox() # å…ˆæŒ‰ç…§bboxcropï¼Œç„¶åæŒ‰ç…§åŸä½ç½®æ”¾ç½®
            except TypeError: # å¦‚æœé‡åˆ°äº†ç©ºå›¾å¯¼è‡´çš„TypeErrorï¼Œç›´æ¥è·³è¿‡è¿™ä¸€å¾ªç¯ï¼Œèµ°åˆ°ä¸‹ä¸€è¡Œ
                continue
            if self.align == 'left':
                canvas.paste(mt_text.crop((p1,p2,p3,p4)),(x+p1,int(y+i*self.MainText.size*self.line_distance+p2)))
            else: # alpha 1.7.0 å…¼å®¹å±…ä¸­
                word_w = p3 - p1
                canvas.paste(mt_text.crop((p1,p2,p3,p4)),
                             (x + (self.MainText.size*self.MainText.line_limit - word_w)//2,
                              int(y+i*self.MainText.size*self.line_distance+p2)
                             )
                            )
        # canvas.save(ofile)
        return canvas
    def display(self,begin,end,text,header='',center='NA'): # è¿™æ®µä»£ç æ˜¯å®Œå…¨æ²¡æœ‰å¯è¯»æ€§çš„å±ï¼Œä½†æ˜¯ç¡®å®å¯è¿è¡Œï¼Œéå¿…è¦ä¸è¦æ”¹
        global outtext_index,clip_tplt,clip_index
        if center == 'NA':
            self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
        else:
            self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
        
        ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
        canvas_draw = self.draw(text,header)
        canvas_draw.save(ofile)
        
        # ç”Ÿæˆåºåˆ—
        width,height = self.size
        pr_horiz,pr_vert = self.PRpos
        if self.path is None:
            clip_bubble = None
            # print('Render empty Bubble!')
        else:
            clip_bubble = clip_tplt.format(**{'clipid':'BB_clip_%d'%clip_index,
                                              'clipname':self.filename,
                                              'timebase':'%d'%frame_rate,
                                              'ntsc':Is_NTSC,
                                              'start':'%d'%begin,
                                              'end':'%d'%end,
                                              'in':'%d'%90000,
                                              'out':'%d'%(90000+end-begin),
                                              'fileid':self.fileindex,
                                              'filename':self.filename,
                                              'filepath':self.path,
                                              'filewidth':'%d'%width,
                                              'fileheight':'%d'%height,
                                              'horiz':'%.5f'%pr_horiz,
                                              'vert':'%.5f'%pr_vert,
                                              'colorlabel':self.label_color})
        clip_text = clip_tplt.format(**{'clipid':'TX_clip_%d'%clip_index,
                                        'clipname':'auto_TX_%d.png'%outtext_index,
                                        'timebase':'%d'%frame_rate,
                                        'ntsc':Is_NTSC,
                                        'start':'%d'%begin,
                                        'end':'%d'%end,
                                        'in':'%d'%90000,
                                        'out':'%d'%(90000+end-begin),
                                        'fileid':'auto_TX_%d'%outtext_index,
                                        'filename':'auto_TX_%d.png'%outtext_index,
                                        'filepath':reformat_path(ofile),
                                        'filewidth':'%d'%width,
                                        'fileheight':'%d'%height,
                                        'horiz':'%.5f'%pr_horiz,
                                        'vert':'%.5f'%pr_vert,
                                        'colorlabel':self.MainText.label_color})
        outtext_index = outtext_index + 1
        clip_index = clip_index+1
        return (clip_bubble,clip_text)

    def convert(self):
        pass

class Balloon(Bubble):
    def __init__(self,filepath=None,Main_Text=Text(),Header_Text=[None],pos=(0,0),mt_pos=(0,0),ht_pos=[(0,0)],ht_target=['Name'],align='left',line_distance=1.5,label_color='Lavender'):
        super().__init__(filepath=filepath,Main_Text=Main_Text,Header_Text=Header_Text,pos=pos,mt_pos=mt_pos,ht_pos=ht_pos,ht_target=ht_target,align=align,line_distance=line_distance,label_color=label_color)
        if len(self.Header)!=len(self.ht_pos) or len(self.Header)!=len(self.target):
            raise MediaError('[31m[BubbleError]:[0m', 'length of header params does not match!')
        else:
            self.header_num = len(self.Header)
    def draw(self, text, header=''):
        # ç”Ÿæˆæ–‡æœ¬å›¾ç‰‡ # åŒBubbleç±»
        canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
        # ç”Ÿæˆå¤´æ–‡æœ¬
        header_texts = header.split('|')
        for i,header_text_this in enumerate(header_texts):
            # Header ä¸ä¸ºNone ï¼Œä¸”è¾“å…¥æ–‡æœ¬ä¸ä¸ºç©º
            if (self.Header[i]!=None) & (header_text_this!=''):
                ht_text = self.Header[i].draw(header_text_this)[0]
                try:
                    p1,p2,p3,p4 = ht_text.getbbox()
                    canvas.paste(ht_text.crop((p1,p2,p3,p4)),(self.ht_pos[i][0]+p1,self.ht_pos[i][1]+p2)) # å…¼å®¹å¾®è½¯é›…é»‘è¿™ç§ï¼Œbboxåˆ°å¤„é£˜çš„å­—ä½“
                except TypeError:
                    pass
            if i == self.header_num -1:
                break
        # ç”Ÿæˆä¸»æ–‡æœ¬ # åŒBubbleç±»
        x,y = self.mt_pos
        for i,mt_text in enumerate(self.MainText.draw(text)):
            try:
                p1,p2,p3,p4 = mt_text.getbbox() # å…ˆæŒ‰ç…§bboxcropï¼Œç„¶åæŒ‰ç…§åŸä½ç½®æ”¾ç½®
            except TypeError: # å¦‚æœé‡åˆ°äº†ç©ºå›¾å¯¼è‡´çš„TypeErrorï¼Œç›´æ¥è·³è¿‡è¿™ä¸€å¾ªç¯ï¼Œèµ°åˆ°ä¸‹ä¸€è¡Œ
                continue
            if self.align == 'left':
                canvas.paste(mt_text.crop((p1,p2,p3,p4)),(x+p1,int(y+i*self.MainText.size*self.line_distance+p2)))
            else: # alpha 1.7.0 å…¼å®¹å±…ä¸­
                word_w = p3 - p1
                canvas.paste(mt_text.crop((p1,p2,p3,p4)),
                             (x + (self.MainText.size*self.MainText.line_limit - word_w)//2,
                              int(y+i*self.MainText.size*self.line_distance+p2)
                             )
                            )
        return canvas

class DynamicBubble(Bubble):
    def __init__(self,filepath=None,Main_Text=Text(),Header_Text=None,pos=(0,0),mt_pos=(0,0),mt_end=(0,0),ht_pos=(0,0),ht_target='Name',fill_mode='stretch',line_distance=1.5,label_color='Lavender'):
        super().__init__(filepath=filepath,Main_Text=Main_Text,Header_Text=Header_Text,pos=pos,mt_pos=mt_pos,ht_pos=ht_pos,ht_target=ht_target,line_distance=line_distance,label_color=label_color)
        if (mt_pos[0] >= mt_end[0]) | (mt_pos[1] >= mt_end[1]) | (mt_end[0] > self.size[0]) | (mt_end[1] > self.size[1]):
            raise MediaError('[31m[BubbleError]:[0m', 'Invalid bubble separate params mt_end!')
        elif (mt_pos[0] < 0) | (mt_pos[1] < 0):
            raise MediaError('[31m[BubbleError]:[0m', 'Invalid bubble separate params mt_pos!')
        else:
            self.mt_end = mt_end
        # fill_mode åªèƒ½æ˜¯ stretch æˆ–è€… collage
        if fill_mode in ['stretch','collage']:
            self.fill_mode = fill_mode
        else:
            raise MediaError('[31m[BubbleError]:[0m', 'Invalid fill mode params ' + fill_mode)
        # x,yè½´ä¸Šçš„å››æ¡åˆ†å‰²çº¿
        self.x_tick = [0,self.mt_pos[0],self.mt_end[0],self.size[0]]
        self.y_tick = [0,self.mt_pos[1],self.mt_end[1],self.size[1]]
        self.bubble_clip = []
        # 0 3 6
        # 1 4 7
        # 2 5 8
        for i in range(0,3):
            for j in range(0,3):
                try:
                    # crop(left, upper, right, lower)
                    self.bubble_clip.append(self.media.crop((self.x_tick[i],self.y_tick[j],
                                                             self.x_tick[i+1],self.y_tick[j+1]
                                                            )))
                except Exception:
                    # æ— æ•ˆçš„clip
                    self.bubble_clip.append(None)
        self.bubble_clip_size = list(map(lambda x:(0,0) if x is None else x.size, self.bubble_clip))

    def draw(self, text, header = ''):
        # é¦–å…ˆï¼Œéœ€è¦æŠŠä¸»æ–‡æœ¬æ¸²æŸ“å‡ºæ¥
        main_text_list = self.MainText.draw(text)
        # ç¬¬ä¸€æ¬¡å¾ªç¯ï¼šè·å–æœ€å¤§çš„xå’Œæœ€å¤§çš„y
        # å¯¼å‡ºPRé¡¹ç›®çš„ç‰¹æ®Šæ€§ï¼šå¦‚æœæ˜¯ä¸€ä¸ªç©ºç™½æ–‡æœ¬ï¼Œé‚£ä¹ˆgetbboxå°†ä¸èƒ½å¾—åˆ°ç†è®ºå°ºå¯¸ã€‚
        # å› æ­¤xlimå’Œylimçš„åˆå§‹å€¼è¢«è®¾ä¸ºåŠä¸ªå­—çš„å¤§å°ã€‚
        xlim = int(self.MainText.size/2)
        ylim = self.MainText.size
        for i,mt_text in enumerate(main_text_list):
            try:
                p1,p2,p3,p4 = mt_text.getbbox() # å…ˆæŒ‰ç…§bboxcropï¼Œç„¶åæŒ‰ç…§åŸä½ç½®æ”¾ç½®
            except TypeError: # å¦‚æœé‡åˆ°äº†ç©ºå›¾å¯¼è‡´çš„TypeErrorï¼Œç›´æ¥è·³è¿‡è¿™ä¸€å¾ªç¯ï¼Œèµ°åˆ°ä¸‹ä¸€è¡Œ
                continue
            # å› ä¸ºè€ƒè™‘åˆ°æœ‰çš„å­—ä½“çš„bboxä¸å¯¹åŠ²ï¼Œå› æ­¤ä¸å‡å»p1,p2ï¼Œä»¥p3ï¼Œp4ä¸ºå‡†
            x_this = p3
            y_this = p4
            y_this = i*self.MainText.size*self.line_distance + y_this
            if x_this > xlim:
                xlim = int(x_this)
            ylim = int(y_this)
        # å»ºç«‹å˜å½¢åçš„æ°”æ³¡
        temp_size_x = xlim + self.x_tick[1] + self.x_tick[3] - self.x_tick[2]
        temp_size_y = ylim + self.y_tick[1] + self.y_tick[3] - self.y_tick[2]
        bubble_canvas = Image.new(mode='RGBA',size=(temp_size_x,temp_size_y),color=(0,0,0,0))
        text_canvas = Image.new(mode='RGBA',size=(temp_size_x,temp_size_y),color=(0,0,0,0))
        # ç”Ÿæˆæ–‡æœ¬å›¾ç‰‡
        # å¤´æ–‡æœ¬
        if (self.Header!=None) & (header!=''):    # Header æœ‰å®šä¹‰ï¼Œä¸”è¾“å…¥æ–‡æœ¬ä¸ä¸ºç©º
            if self.ht_pos[0] > self.x_tick[2]:
                ht_renderpos_x = self.ht_pos[0] - self.x_tick[2] + self.x_tick[1] + xlim
            else:
                ht_renderpos_x = self.ht_pos[0]
            if self.ht_pos[1] > self.y_tick[2]:
                ht_renderpos_y = self.ht_pos[1] - self.y_tick[2] + self.y_tick[1] + ylim
            else:
                ht_renderpos_y = self.ht_pos[1]
            ht_text = self.Header.draw(header)[0]
            try:
                p1,p2,p3,p4 = ht_text.getbbox() # å¦‚æœæ˜¯ç©ºå›¾çš„è¯ï¼Œgetbboxè¿”å›Noneï¼Œä¼šå‘ç”ŸTypeError
                text_canvas.paste(ht_text.crop((p1,p2,p3,p4)),(ht_renderpos_x+p1,ht_renderpos_y+p2)) # å…¼å®¹å¾®è½¯é›…é»‘è¿™ç§ï¼Œbboxåˆ°å¤„é£˜çš„å­—ä½“
            except TypeError:
                pass
        # ä¸»æ–‡æœ¬
        for i,mt_text in enumerate(main_text_list):
            try:
                p1,p2,p3,p4 = mt_text.getbbox() # å…ˆæŒ‰ç…§bboxcropï¼Œç„¶åæŒ‰ç…§åŸä½ç½®æ”¾ç½®
            except TypeError: # å¦‚æœé‡åˆ°äº†ç©ºå›¾å¯¼è‡´çš„TypeErrorï¼Œç›´æ¥è·³è¿‡è¿™ä¸€å¾ªç¯ï¼Œèµ°åˆ°ä¸‹ä¸€è¡Œ
                continue
            text_canvas.paste(mt_text.crop((p1,p2,p3,p4)),(self.x_tick[1]+p1,int(self.y_tick[1]+i*self.MainText.size*self.line_distance+p2)))

        # return ofile
        # æ°”æ³¡ç¢ç‰‡çš„æ¸²æŸ“ä½ç½®
        bubble_clip_pos = {
            0:(0,0),
            1:(0,self.y_tick[1]),
            2:(0,self.y_tick[1]+ylim),
            3:(self.x_tick[1],0),
            4:(self.x_tick[1],self.y_tick[1]),
            5:(self.x_tick[1],self.y_tick[1]+ylim),
            6:(self.x_tick[1]+xlim,0),
            7:(self.x_tick[1]+xlim,self.y_tick[1]),
            8:(self.x_tick[1]+xlim,self.y_tick[1]+ylim)
        }
        # æ°”æ³¡ç¢ç‰‡çš„ç›®æ ‡å¤§å°
        bubble_clip_scale = {
            0:False,
            1:(self.x_tick[1],ylim),
            2:False,
            3:(xlim,self.y_tick[1]),
            4:(xlim,ylim),
            5:(xlim,self.y_tick[3]-self.y_tick[2]),
            6:False,
            7:(self.x_tick[3]-self.x_tick[2],ylim),
            8:False
        }
        for i in range(0,9):
            if 0 in self.bubble_clip_size[i]:
                continue
            else:
                if bubble_clip_scale[i] == False:
                    bubble_canvas.paste(self.bubble_clip[i],bubble_clip_pos[i])
                else:
                    if self.fill_mode == 'stretch':
                        bubble_canvas.paste(self.bubble_clip[i].resize(bubble_clip_scale[i]),bubble_clip_pos[i])
                    elif self.fill_mode == 'collage':
                        # æ–°å»ºæ‹¼è´´å›¾å±‚ï¼Œå°ºå¯¸ä¸ºæ°”æ³¡ç¢ç‰‡çš„ç›®æ ‡å¤§å°
                        collage_canvas = Image.new(mode='RGBA',size=bubble_clip_scale[i],color=(0,0,0,0))
                        col_x,col_y = (0,0)
                        while col_y < bubble_clip_scale[i][1]:
                            col_x = 0
                            while col_x < bubble_clip_scale[i][0]:
                                collage_canvas.paste(self.bubble_clip[i],(col_x,col_y))
                                col_x = col_x + self.bubble_clip_size[i][0]
                            col_y = col_y + self.bubble_clip_size[i][1]
                        bubble_canvas.paste(collage_canvas,bubble_clip_pos[i])
        # å¦‚æœæ°”æ³¡å›¾æ˜¯ç©ºçš„ï¼Œåˆ™è¿”å›ç©º
        if bubble_canvas.getbbox() is None:
            return None,text_canvas
        # æ— è®ºæ–‡æœ¬å›¾æ˜¯ä¸æ˜¯ç©ºçš„ï¼Œå‡æ­£å¸¸ä¿å­˜ä¸ºæ–‡ä»¶ã€‚
        else:
            return bubble_canvas,text_canvas
    def display(self,begin,end,text,header='',center='NA'): # è¿™æ®µä»£ç æ˜¯å®Œå…¨æ²¡æœ‰å¯è¯»æ€§çš„å±ï¼Œä½†æ˜¯ç¡®å®å¯è¿è¡Œï¼Œéå¿…è¦ä¸è¦æ”¹
        global outtext_index,clip_tplt,clip_index
        # å…ˆç”Ÿæˆæ–‡ä»¶
        bubble_ofile = output_path+'/auto_BB_%d'%outtext_index+'.png'
        text_ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'

        bubble_canvas,text_canvas = self.draw(text,header)
        temp_size = text_canvas.size

        # ä¿å­˜æ–‡ä»¶
        text_canvas.save(text_ofile)

        # è·å–åŠ¨æ€æ°”æ³¡çš„å‚æ•°
        width,height = temp_size
        # è·å–PRä½ç½®å‚æ•°
        if center == 'NA':
            self.PRpos = PR_center_arg(np.array(temp_size),np.array(self.pos.get()))
        else:
            self.PRpos = PR_center_arg(np.array(temp_size),np.array(Pos(*eval(center)).get()))
        pr_horiz,pr_vert = self.PRpos
        # ç”Ÿæˆåºåˆ—
        if bubble_canvas is None:
            clip_bubble = None
            # print('Render empty Bubble!')
        else:
            # å…ˆä¿å­˜æ°”æ³¡å›¾ç‰‡
            bubble_canvas.save(bubble_ofile)
            clip_bubble = clip_tplt.format(**{'clipid':'BB_clip_%d'%clip_index,
                                              'clipname':'auto_BB_%d.png'%outtext_index,
                                              'timebase':'%d'%frame_rate,
                                              'ntsc':Is_NTSC,
                                              'start':'%d'%begin,
                                              'end':'%d'%end,
                                              'in':'%d'%90000,
                                              'out':'%d'%(90000+end-begin),
                                              'fileid':'auto_BB_%d'%outtext_index,
                                              'filename':'auto_BB_%d.png'%outtext_index,
                                              'filepath':reformat_path(bubble_ofile),
                                              'filewidth':'%d'%width,
                                              'fileheight':'%d'%height,
                                              'horiz':'%.5f'%pr_horiz,
                                              'vert':'%.5f'%pr_vert,
                                              'colorlabel':self.label_color})
        # txçš„clip
        clip_text = clip_tplt.format(**{'clipid':'TX_clip_%d'%clip_index,
                                        'clipname':'auto_TX_%d.png'%outtext_index,
                                        'timebase':'%d'%frame_rate,
                                        'ntsc':Is_NTSC,
                                        'start':'%d'%begin,
                                        'end':'%d'%end,
                                        'in':'%d'%90000,
                                        'out':'%d'%(90000+end-begin),
                                        'fileid':'auto_TX_%d'%outtext_index,
                                        'filename':'auto_TX_%d.png'%outtext_index,
                                        'filepath':reformat_path(text_ofile),
                                        'filewidth':'%d'%width,
                                        'fileheight':'%d'%height,
                                        'horiz':'%.5f'%pr_horiz,
                                        'vert':'%.5f'%pr_vert,
                                        'colorlabel':self.MainText.label_color})
        outtext_index = outtext_index + 1
        clip_index = clip_index+1
        return (clip_bubble,clip_text)

class ChatWindow(Bubble):
    def __init__(self,filepath=None,sub_key=['Key1'],sub_Bubble=[Bubble()],sub_Anime=[],sub_align=[],pos=(0,0),sub_pos=(0,0),sub_end=(0,0),am_left=0,am_right=0,sub_distance=50,label_color='Lavender'):
        global file_index
        if len(sub_Bubble) != len(sub_key):
            raise MediaError('[31m[BubbleError]:[0m', 'length of sub-key and sub-bubble does not match!')
        # ç©ºç™½åº•å›¾
        if filepath is None or filepath == 'None':
            self.path = None
            self.media = None
            self.size = screen_size
            self.filename = None
        else:
            self.path = reformat_path(filepath)
            self.media = Image.open(filepath).convert('RGBA')
            self.size = self.media.size
            self.filename = self.path.split('/')[-1]
        # ä½ç½®
        if type(pos) in [Pos,FreePos]:
            self.pos = pos
        else:
            self.pos = Pos(*pos)
        # å­æ°”æ³¡å’Œå¯¹é½
        self.sub_Bubble = {}
        self.sub_Anime = {}
        self.sub_align = {}
        for i,key in enumerate(sub_key):
            # æ£€æŸ¥æ°”æ³¡æ˜¯å¦æ˜¯ Ballon
            if type(sub_Bubble[i]) is Balloon:
                raise MediaError('[31m[BubbleError]:[0m','Ballon object "'+key+'" is not supported to be set as a sub-bubble of ChatWindow!')
            self.sub_Bubble[key] = sub_Bubble[i]
            # è½½å…¥å¯¹é½ï¼Œé»˜è®¤æ˜¯å·¦å¯¹é½
            try:
                if sub_align[i] in ['left','right']:
                    self.sub_align[key] = sub_align[i]
                else:
                    raise MediaError('[31m[BubbleError]:[0m', 'Unsupported align:',sub_align[i])
            except IndexError:
                self.sub_align[key] = 'left'
            # è½½å…¥å­ç«‹ç»˜ï¼Œé»˜è®¤æ˜¯None
            try:
                self.sub_Anime[key] = sub_Anime[i]
            except IndexError:
                self.sub_Anime[key] = None
        # å­æ°”æ³¡å°ºå¯¸
        if (sub_pos[0] >= sub_end[0]) | (sub_pos[1] >= sub_end[1]):
            raise MediaError('[31m[BubbleError]:[0m', 'Invalid bubble separate params sub_end!')
        else:
            self.sub_size = (sub_end[0]-sub_pos[0],sub_end[1]-sub_pos[1])
            self.sub_pos = sub_pos
        # ç«‹ç»˜å¯¹é½ä½ç½®
        if am_left >= am_right:
            raise MediaError('[31m[BubbleError]:[0m', 'Invalid bubble separate params am_right!')
        else:
            self.am_left = am_left
            self.am_right = am_right
        # å­æ°”æ³¡é—´éš”
        self.sub_distance = sub_distance
        # ç•™å­˜æ–‡æœ¬å®¹å™¨-è¿™è¾¹åº”è¯¥ç”¨ä¸åˆ°ï¼š
        self.main_text = ''
        self.header_text = ''
        # å…¶ä»–æ°”æ³¡ç±»clipçš„å¿…è¦å‚æ•°
        self.fileindex = 'BBfile_' + '%d'% file_index
        self.label_color = label_color
        # è¿™ä¸ªMainTextåªæ˜¯ç”¨æ¥ç»™labelcoloråšå‚è€ƒç”¨çš„ã€‚
        self.MainText = self.sub_Bubble[sub_key[0]].MainText
        file_index = file_index+1

    # æ¸²æŸ“æ°”æ³¡ä¸­çš„æ–‡æœ¬ï¼Œå¯¹äºCWæ¥è¯´ï¼ŒåŒ…æ‹¬å­æ°”æ³¡çš„çª—ä½“å’ŒPCå¤´åƒéƒ½åœ¨è¿™é‡Œç”Ÿæˆã€‚
    def draw(self, text, header=''):
        # ç”Ÿæˆæ–‡æœ¬å›¾ç‰‡
        ofile = output_path+'/auto_TX_%d'%outtext_index+'.png'
        # ä¸»å®¹å™¨ï¼Œå®¹çº³æ•´ä¸ªæ–‡æœ¬å›¾
        canvas = Image.new(mode='RGBA',size=self.size,color=(0,0,0,0))
        # å­æ°”æ³¡å®¹å™¨ï¼Œå®¹çº³è‹¥å¹²ä¸ªå­æ°”æ³¡åŠå…¶æ–‡æœ¬
        sub_canvas = Image.new(mode='RGBA',size=self.sub_size,color=(0,0,0,0))
        # ç«‹ç»˜å®¹å™¨ï¼Œå®¹çº³è‹¥å¹²ä¸ªç«‹ç»˜
        am_canvas = Image.new(mode='RGBA',size=(self.am_right-self.am_left,self.sub_size[1]),color=(0,0,0,0))
        # æ‹†åˆ†ä¸»æ–‡æœ¬å’Œå¤´æ–‡æœ¬
        main_text_list = text.split('|')
        header_text_list = header.split('|')
        header_main_pair = []
        for i,main_text in enumerate(main_text_list):
            header_main_pair.append((header_text_list[i],main_text))
        # å°†å¤´ä¸»æ–‡æœ¬å¯¹åˆ—è¡¨å€’åº
        header_main_pair = header_main_pair[::-1]
        # ç¬¬äºŒæ¬¡å¾ªç¯ï¼šæ¸²æŸ“å­æ°”æ³¡
        y_bottom = self.sub_size[1] # å½“å‰å¥å­çš„å¯ç”¨yåº•éƒ¨
        for header_main in header_main_pair:
            # è§£æ(é”®#å¤´æ–‡æœ¬,ä¸»æ–‡æœ¬)
            bubble_header_this,main_this = header_main
            key_this,header_this = bubble_header_this.split('#')
            # ç»˜åˆ¶å­æ°”æ³¡
            if type(self.sub_Bubble[key_this]) is DynamicBubble:
                bubble_canvas,text_canvas = self.sub_Bubble[key_this].draw(main_this,header_this)
            else:
                text_canvas = self.sub_Bubble[key_this].draw(main_this,header_this)
                bubble_canvas = self.sub_Bubble[key_this].media
            if bubble_canvas is not None:
                bubble_canvas.paste(text_canvas,(0,0),mask=text_canvas)
                subbubble_canvas = bubble_canvas
            else:
                subbubble_canvas = text_canvas
            subbubble_size = subbubble_canvas.size
            if self.sub_align[key_this] == 'left':
                sub_canvas.paste(subbubble_canvas,(0,y_bottom-subbubble_size[1]))
                if self.sub_Anime[key_this] is not None:
                    am_canvas.paste(self.sub_Anime[key_this].media,(0,y_bottom-subbubble_size[1]))
            else:
                sub_canvas.paste(subbubble_canvas,(self.sub_size[0]-subbubble_size[0],y_bottom-subbubble_size[1]))
                if self.sub_Anime[key_this] is not None:
                    am_canvas.paste(self.sub_Anime[key_this].media,(self.am_right-self.am_left-self.sub_Anime[key_this].size[0],y_bottom-subbubble_size[1]))
            # æ›´æ–°å¯ç”¨åº•éƒ¨ = å‰ä¸€æ¬¡åº•éƒ¨ - å­æ°”æ³¡é«˜åº¦ - å­æ°”æ³¡é—´è·
            y_bottom = y_bottom - subbubble_size[1] - self.sub_distance
            # å¦‚æœå¯ç”¨åº•éƒ¨å·²ç»è¾¾åˆ°é¡¶éƒ¨ä¹‹å¤–
            if y_bottom < 0:
                break            
        # å°†å­æ°”æ³¡å®¹å™¨æ¸²æŸ“åˆ°æ¯æ°”æ³¡å®¹å™¨
        canvas.paste(sub_canvas,self.sub_pos)
        canvas.paste(am_canvas,(self.am_left,self.sub_pos[1]),mask=am_canvas)
        return canvas

# èƒŒæ™¯å›¾ç‰‡
class Background:
    def __init__(self,filepath,pos = (0,0),label_color='Lavender'):
        global file_index 
        # å¯¹çº¯è‰²å®šä¹‰çš„èƒŒæ™¯çš„æ”¯æŒ
        if filepath in cmap.keys():
            # æ–°å»ºå›¾åƒï¼Œå¹¶ä¿å­˜
            ofile = output_path+'/auto_BG_'+filepath+'.png'
            self.media = Image.new(mode='RGBA',size=screen_size,color=cmap[filepath])
            self.media.save(ofile)
            # è·¯å¾„å’Œå°ºå¯¸
            self.path = reformat_path(ofile)
            self.size = screen_size
        else:
            self.path = reformat_path(filepath)
            self.media = Image.open(filepath).convert('RGBA')
            self.size = self.media.size
        if type(pos) in [Pos,FreePos]:
            self.pos = pos
        else:
            self.pos = Pos(*pos)
        # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
        self.filename = self.path.split('/')[-1]
        self.fileindex = 'BGfile_%d'% file_index
        self.label_color = label_color
        file_index = file_index+1
    def display(self,begin,end,center='NA'):
        global clip_tplt,clip_index
        if center == 'NA':
            self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
        else:
            self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
        width,height = self.size
        pr_horiz,pr_vert = self.PRpos
        clip_this = clip_tplt.format(**{'clipid':'BG_clip_%d'%clip_index,
                              'clipname':self.filename,
                              'timebase':'%d'%frame_rate,
                              'ntsc':Is_NTSC,
                              'start':'%d'%begin,
                              'end':'%d'%end,
                              'in':'%d'%90000,
                              'out':'%d'%(90000+end-begin),
                              'fileid':self.fileindex,
                              'filename':self.filename,
                              'filepath':self.path,
                              'filewidth':'%d'%width,
                              'fileheight':'%d'%height,
                              'horiz':'%.5f'%pr_horiz,
                              'vert':'%.5f'%pr_vert,
                              'colorlabel':self.label_color})
        clip_index = clip_index+1
        return clip_this
    def convert(self):
        pass

# ç«‹ç»˜å›¾ç‰‡
class Animation:
    def __init__(self,filepath,pos = (0,0),tick=1,loop=True,label_color='Lavender'):
        global file_index 
        self.path = reformat_path(glob.glob(filepath)[0]) # å…¼å®¹åŠ¨ç”»Animationï¼Œåªä½¿ç”¨ç¬¬ä¸€å¸§ï¼
        self.media = Image.open(glob.glob(filepath)[0].replace('\\','/')).convert('RGBA')
        self.size = self.media.size
        self.filename = self.path.split('/')[-1]
        if type(pos) in [Pos,FreePos]:
            self.pos = pos
        else:
            self.pos = Pos(*pos)
        self.fileindex = 'AMfile_%d'% file_index
        # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
        self.label_color = label_color
        file_index = file_index+1
    def display(self,begin,end,center='NA'):
        global clip_tplt,clip_index
        if center == 'NA':
            self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
        else:
            self.PRpos = PR_center_arg(np.array(self.size),np.array(Pos(*eval(center)).get()))
        width,height = self.size
        pr_horiz,pr_vert = self.PRpos
        clip_this = clip_tplt.format(**{'clipid':'AM_clip_%d'%clip_index,
                              'clipname':self.filename,
                              'timebase':'%d'%frame_rate,
                              'ntsc':Is_NTSC,
                              'start':'%d'%begin,
                              'end':'%d'%end,
                              'in':'%d'%90000,
                              'out':'%d'%(90000+end-begin),
                              'fileid':self.fileindex,
                              'filename':self.filename,
                              'filepath':self.path,
                              'filewidth':'%d'%width,
                              'fileheight':'%d'%height,
                              'horiz':'%.5f'%pr_horiz,
                              'vert':'%.5f'%pr_vert,
                              'colorlabel':self.label_color})
        clip_index = clip_index+1
        return clip_this
    def convert(self):
        pass

# a 1.13.5 ç»„åˆç«‹ç»˜ï¼ŒAnimationç±»çš„å­ç±»ï¼Œç»„åˆç«‹ç»˜åªèƒ½æ˜¯é™æ€ç«‹ç»˜ï¼
class GroupedAnimation(Animation):
    def __init__(self,subanimation_list,subanimation_current_pos=None,label_color='Mango'):
        global file_index,outanime_index
        ofile = output_path+'/auto_GA_%d'%outanime_index+'.png'
        canvas = Image.new(size=screen_size,mode='RGBA',color=(0,0,0,0))
        # å¦‚æœå¤–éƒ¨æœªæŒ‡å®šä½ç½®å‚æ•°ï¼Œåˆ™ä½¿ç”¨å­Animationç±»çš„è‡ªèº«çš„pos
        if subanimation_current_pos is None:
            subanimation_current_pos = [None]*len(subanimation_list)
        # å¦‚æœæŒ‡å®šçš„ä½ç½®å‚æ•°å’Œå­Animationçš„æ•°é‡ä¸ä¸€è‡´ï¼ŒæŠ¥å‡ºæŠ¥é”™
        elif len(subanimation_current_pos) != len(subanimation_list):
            raise MediaError('[31m[AnimationError]:[0m','length of subanimation params does not match!')
        # å¼€å§‹åœ¨ç”»æ¿ä¸Šç»˜åˆ¶ç«‹ç»˜
        else:
            # è¶Šåé¢çš„ä½äºè¶Šä¸Šå±‚çš„å›¾å±‚
            # [zhang,drink_left] [(0,0),(0,0)] # list of Animation/str | list of tuple/str
            for am_name,am_pos in zip(subanimation_list,subanimation_current_pos):
                # åˆ¤æ–­AM
                try:
                    if type(am_name) in [Animation,BuiltInAnimation,GroupedAnimation]:
                        subanimation = am_name
                    else: # type(am_name) is str
                        subanimation = eval(am_name)
                except NameError as E:
                    raise MediaError('[31m[AnimationError]:[0m','The Animation "'+ am_name +'" is not defined, which was tried to group into GroupedAnimation!')
                if am_pos is None:
                    # æ‰“å¼€ subanimation çš„å›¾ç‰‡å¯¹è±¡ï¼Œå°†å…¶æŒ‰ç…§self.pos, pasteåˆ°canvas
                    canvas.paste(subanimation.media,subanimation.pos.get(),mask=subanimation.media)
                else:
                    # æ‰“å¼€ subanimation çš„å›¾ç‰‡å¯¹è±¡ï¼Œå°†å…¶æŒ‰ç…§am_pos, pasteåˆ°canvas
                    canvas.paste(subanimation.media,am_pos,mask=subanimation.media)
        # ä¿å­˜æ–‡ä»¶
        canvas.save(ofile)
        self.pos = Pos(0,0)
        self.path = reformat_path(ofile)
        self.size = screen_size
        self.filename = 'auto_GA_%d'%outanime_index+'.png'
        self.fileindex = 'AMfile_%d'% file_index
        self.label_color = label_color
        file_index = file_index+1
        outanime_index = outanime_index+1
# a1.6.5 å†…å»ºåŠ¨ç”»ï¼Œè¿™æ˜¯ä¸€ä¸ªAnimationç±»çš„å­ç±»ï¼Œé‡æ„äº†æ„é€ å‡½æ•°
class BuiltInAnimation(Animation):
    def __init__(self,anime_type='hitpoint',anime_args=('0',0,0,0),screensize = (1920,1080),layer=0,label_color='Mango'):
        global file_index,outanime_index
        self.label_color = label_color
        if anime_type == 'hitpoint':
            # è½½å…¥å›¾ç‰‡
            heart = Image.open('./media/heart.png')
            heart_shape = Image.open('./media/heart_shape.png')
            hx,hy = heart.size
            # é‡è®¾å›¾ç‰‡å°ºå¯¸ï¼Œæ ¹æ®screensize[0]
            if screensize[0]!=1920:
                multip = screensize[0]/1920
                heart = heart.resize((int(hx*multip),int(hy*multip)))
                heart_shape = heart_shape.resize((int(hx*multip),int(hy*multip)))
                hx,hy = heart.size
            # åŠ¨ç”»å‚æ•°
            name_tx,heart_max,heart_begin,heart_end = anime_args
            if (heart_end==heart_begin)|(heart_max<max(heart_begin,heart_end)):
                raise MediaError('[BIAnimeError]:','Invalid argument',name_tx,heart_max,heart_begin,heart_end,'for BIAnime hitpoint!')
            elif heart_end > heart_begin: # å¦‚æœæ˜¯ç”Ÿå‘½æ¢å¤
                temp = heart_end
                heart_end = heart_begin
                heart_begin = temp # åˆ™äº’æ¢é¡ºåº ç¡®ä¿ beginä¸€å®šæ˜¯å°äºendçš„

            distance = int(0.026*screensize[0]) # default = 50

            total_heart = int(heart_max/2 * hx + max(0,np.ceil(heart_max/2-1)) * distance) #ç”»å¸ƒæ€»é•¿
            left_heart = int(heart_end/2 * hx + max(0,np.ceil(heart_end/2-1)) * distance) #ç”»å¸ƒæ€»é•¿
            lost_heart = int((heart_begin-heart_end)/2 * hx + np.floor((heart_begin-heart_end)/2) * distance)
            # å§“åæ–‡æœ¬
            BIA_text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0521*screensize[0])) # 1080p:size=100
            test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
            test_draw = ImageDraw.Draw(test_canvas)
            test_draw.text((0,0), name_tx, font = BIA_text, align ="left",fill = (255,255,255,255))
            try:
                p1,p2,p3,p4 = test_canvas.getbbox()
            except TypeError:
                p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
            nx = p3 - p1
            ny = p4 - p2
            nametx_surf = test_canvas.crop((p1,p2,p3,p4))
            # å¼€å§‹åˆ¶å›¾
            if layer==0: # åº•å±‚ é˜´å½±å›¾
                self.pos = Pos((screensize[0]-max(nx,total_heart))/2,(4/5*screensize[1]-hy-ny)/2)
                canvas = Image.new(size=(max(nx,total_heart),hy+ny+screensize[1]//5),mode='RGBA',color=(0,0,0,0))
                self.size = canvas.size
                if nx > total_heart:
                    canvas.paste(nametx_surf,(0,0))
                    posx = (nx-total_heart)//2
                else:
                    canvas.paste(nametx_surf,((total_heart-nx)//2,0))
                    posx = 0
                posy = ny+screensize[1]//5
                for i in range(1,heart_max+1): # å¶æ•°ï¼Œä½äºæœ€ç»ˆè¡€é‡
                    if i%2 == 0:
                        canvas.paste(heart_shape,(posx,posy))
                        posx = posx + hx + distance
                    else:
                        pass
                if heart_max%2 == 1: # maxæ˜¯å¥‡æ•°
                    left_heart_shape = heart_shape.crop((0,0,int(hx/2),hy))
                    canvas.paste(left_heart_shape,(total_heart-int(hx/2),posy))
            elif layer==1: # å‰©ä½™çš„è¡€é‡
                self.pos = Pos((screensize[0]-total_heart)/2,3/5*screensize[1]+ny/2-hy/2)
                # 1.6.5 é˜²æ­¢æŠ¥é”™ å‰©ä½™è¡€é‡å³ä½¿æ˜¯ç©ºå›¾ï¼Œä¹Ÿè¦è‡³å°‘å®½30pix
                canvas = Image.new(size=(max(30,left_heart),hy),mode='RGBA',color=(0,0,0,0)) 
                self.size = canvas.size
                posx,posy = 0,0
                for i in range(1,heart_end+1): # å¶æ•°ï¼Œä½äºæœ€ç»ˆè¡€é‡
                    if i%2 == 0:
                        canvas.paste(heart,(posx,posy))
                        posx = posx + hx + distance
                    else:
                        pass
                if heart_end%2 == 1: # endæ˜¯å¥‡æ•°
                    left_heart = heart.crop((0,0,int(hx/2),hy))
                    canvas.paste(left_heart,(heart_end//2*(hx + distance),0))
            elif layer==2: # æŸå¤±/æ¢å¤çš„è¡€é‡
                self.pos = Pos(heart_end//2*(hx + distance)+(heart_end%2)*int(hx/2)+(screensize[0]-total_heart)/2,3/5*screensize[1]+ny/2-hy/2)
                canvas = Image.new(size=(lost_heart,hy),mode='RGBA',color=(0,0,0,0))
                self.size = canvas.size
                posx,posy = 0,0
                for i in range(1,heart_begin-heart_end+1): 
                    if (i == 1)&(heart_end%2 == 1): # å¦‚æœendæ˜¯å¥‡æ•°ï¼Œå…ˆæ¥åŠä¸ªå³è¾¹
                        right_heart = heart.crop((int(hx/2),0,hx,hy))
                        canvas.paste(right_heart,(posx,posy))
                        posx = posx + int(hx/2) + distance
                    elif ((i - heart_end%2)%2 == 0): # å¦‚æœå’Œendçš„å·®å€¼æ˜¯
                        canvas.paste(heart,(posx,posy))
                        posx = posx + hx + distance
                    elif (i == heart_begin-heart_end)&(heart_begin%2 == 1): # å¦‚æœæœ€å³è¾¹è¾¹ä¹Ÿæ˜¯åŠä¸ªå¿ƒ
                        left_heart = heart.crop((0,0,int(hx/2),hy))
                        canvas.paste(left_heart,(posx,posy))
                    else:
                        pass
            else:
                pass
            ofile = output_path+'/auto_BIA_%d'%outanime_index+'.png'
            canvas.save(ofile)

            #å‰©ä¸‹çš„éœ€è¦å®šä¹‰çš„
            self.media = canvas
            self.path = reformat_path(ofile) # å…¼å®¹åŠ¨ç”»Animationï¼Œåªä½¿ç”¨ç¬¬ä¸€å¸§ï¼
            self.filename = 'auto_BIA_%d'%outanime_index+'.png'
            self.fileindex = 'AMfile_%d'% file_index
            # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            outanime_index = outanime_index+1
            file_index = file_index+1
        if anime_type == 'dice':
            for die in anime_args:
                try:
                    # è½¬æ¢ä¸ºintç±»å‹ï¼ŒNAè½¬æ¢ä¸º-1
                    name_tx,dice_max,dice_check,dice_face = die
                    dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                except ValueError as E: #too many values to unpack,not enough values to unpack
                    raise MediaError('[BIAnimeError]:','Invalid syntax:',str(die),E)
                if (dice_face>dice_max)|(dice_check<-1)|(dice_check>dice_max)|(dice_face<0)|(dice_max<=0):
                    raise MediaError('[BIAnimeError]:','Invalid argument',name_tx,dice_max,dice_check,dice_face,'for BIAnime dice!')
            N_dice = len(anime_args)
            if N_dice > 4:
                N_dice=4
                anime_args = anime_args[0:4]# æœ€å¤š4ä¸ª
            y_anchor = {4:int(0.1667*screensize[1]),3:int(0.25*screensize[1]),2:int(0.3333*screensize[1]),1:int(0.4167*screensize[1])}[N_dice]
            y_unit = int(0.1667*screensize[1])
            BIA_text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0521*screensize[0]))
            if layer==0: # åº•å±‚ åå­— /æ£€å®š
                canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                for i,die in enumerate(anime_args): 
                    name_tx,dice_max,dice_check,dice_face = die
                    dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                    # æ¸²æŸ“
                    test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                    test_draw = ImageDraw.Draw(test_canvas)
                    test_draw.text((0,0), name_tx, font = BIA_text, align ="left",fill = (255,255,255,255))
                    try:
                        p1,p2,p3,p4 = test_canvas.getbbox() # é‡æ–°åŒ…è£…ä¸ºå‡½æ•°ï¼Ÿ
                    except TypeError:
                        p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
                    nx = p3 - p1
                    ny = p4 - p2
                    name_surf = test_canvas.crop((p1,p2,p3,p4))
                    canvas.paste(name_surf,(int(0.3125*screensize[0])-nx//2,y_anchor+i*y_unit+(y_unit-ny)//2)) # 0.3125*screensize[0] = 600
                    if dice_check != -1:
                        test_canvas = Image.new(mode='RGBA',size=screensize,color=(0,0,0,0))
                        test_draw = ImageDraw.Draw(test_canvas)
                        test_draw.text((0,0), '/%d'%dice_check, font = BIA_text, align ="left",fill = (255,255,255,255))
                        try:
                            p1,p2,p3,p4 = test_canvas.getbbox()
                        except TypeError:
                            p1,p2,p3,p4 = (0,0,1,int(0.0521*screensize[0])) # nx=1 ny =fontsize
                        #cx = p3 - p1
                        cy = p4 - p2
                        check_surf = test_canvas.crop((p1,p2,p3,p4))
                        canvas.paste(check_surf,(int(0.7292*screensize[0]),y_anchor+i*y_unit+(y_unit-cy)//2)) # 0.7292*screensize[0] = 1400
                self.size = screen_size
                self.pos = Pos(0,0)
            elif layer==1: #æ— æ³•æ˜¾ç¤ºåŠ¨æ€ï¼Œç•™ç©ºç™½
                canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit*N_dice),color=(0,0,0,0))
                self.size = (int(0.1458*screensize[0]),y_unit*N_dice)
                self.pos = Pos(int(0.5833*screensize[0]),y_anchor)
            elif layer==2:
                dice_cmap={3:(124,191,85,255),1:(94,188,235,255),0:(245,192,90,255),2:(233,86,85,255),-1:(255,255,255,255)}
                canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit*N_dice),color=(0,0,0,0))
                self.size = (int(0.1458*screensize[0]),y_unit*N_dice)
                self.pos = Pos(int(0.5833*screensize[0]),y_anchor)
                for i,die in enumerate(anime_args): 
                    name_tx,dice_max,dice_check,dice_face = die
                    dice_max,dice_face,dice_check = map(lambda x:-1 if x=='NA' else int(x),(dice_max,dice_face,dice_check))
                    significant = 0.05 # å¤§æˆåŠŸå¤±è´¥é˜ˆå€¼
                    if dice_check == -1:
                        color_flag = -1
                    else:
                        color_flag = ((dice_face/dice_max<=significant)|(dice_face/dice_max>(1-significant)))*2 + (dice_face<=dice_check)
                    BIA_color_Text = ImageFont.truetype('./media/SourceHanSerifSC-Heavy.otf', int(0.0651*screensize[0]))
                    test_canvas = Image.new(mode='RGBA',size=(int(0.1458*screensize[0]),y_unit),color=(0,0,0,0))
                    test_draw = ImageDraw.Draw(test_canvas)
                    test_draw.text((0,0),str(dice_face),font=BIA_color_Text,align="left",fill=dice_cmap[color_flag])
                    try:
                        p1,p2,p3,p4 = test_canvas.getbbox()
                    except TypeError:
                        p1,p2,p3,p4 = (0,0,1,int(0.0651*screensize[0])) # nx=1 ny =fontsize
                    fx = p3 - p1
                    fy = p4 - p2
                    face_surf = test_canvas.crop((p1,p2,p3,p4))
                    canvas.paste(face_surf,(int(0.1458*screensize[0]-fx-0.0278*screensize[1]),i*y_unit+(y_unit-fy)//2))
            else:
                pass
            ofile = output_path+'/auto_BIA_%d'%outanime_index+'.png'
            canvas.save(ofile)
            self.media = canvas
            self.path = reformat_path(ofile) # å…¼å®¹åŠ¨ç”»Animationï¼Œåªä½¿ç”¨ç¬¬ä¸€å¸§ï¼
            self.filename = 'auto_BIA_%d'%outanime_index+'.png'
            self.fileindex = 'AMfile_%d'% file_index
            # self.PRpos = PR_center_arg(np.array(self.size),np.array(self.pos.get()))
            outanime_index = outanime_index+1
            file_index = file_index+1
            
# éŸ³æ•ˆ
class Audio:
    def __init__(self,filepath,label_color='Caribbean'):
        global file_index 
        self.path = reformat_path(filepath)
        self.length = get_audio_length(filepath)*frame_rate
        self.filename = self.path.split('/')[-1]
        self.fileindex = 'AUfile_%d'% file_index
        self.label_color = label_color
        file_index = file_index+1
        
    def display(self,begin):
        global audio_clip_tplt,clip_index
        clip_this = audio_clip_tplt.format(**{'clipid':'AU_clip_%d'%clip_index,
                                              'type':Audio_type,
                                              'clipname':self.filename,
                                              'audiolen':'%d'%self.length,
                                              'timebase':'%d'%frame_rate,
                                              'ntsc':Is_NTSC,
                                              'start':'%d'%begin,
                                              'end':'%d'%(begin+self.length),
                                              'in':'0',
                                              'out':'%d'%self.length,
                                              'fileid':self.fileindex,
                                              'filename':self.filename,
                                              'filepath':self.path,
                                              'colorlabel':self.label_color})
        clip_index = clip_index+1
        return clip_this
    
    def convert(self):
        pass

# èƒŒæ™¯éŸ³ä¹
class BGM:
    def __init__(self,filepath,volume=100,loop=True,label_color='Forest'):
        print('[33m[warning]:[0m BGM '+filepath+' is automatically ignored, you should add BGM manually in Premiere Pro later.')
    def convert(self):
        pass

# å‡½æ•°å®šä¹‰

# è·å–éŸ³é¢‘é•¿åº¦
def get_audio_length(filepath):
    mixer.init()
    try:
        this_audio = mixer.Sound(filepath)
    except Exception as E:
        print('[33m[warning]:[0m Unable to get audio length of '+str(filepath)+', due to:',E)
        return np.nan
    return this_audio.get_length()

# é‡æ ¼å¼åŒ–è·¯å¾„
def reformat_path(path): # alpha 1.9.5 æ”¯æŒunixæ–‡ä»¶ç³»ç»Ÿè·¯å¾„
    # è·å–ç»å¯¹è·¯å¾„
    path = os.path.abspath(path)
    # æ£€æŸ¥éæ³•ç¬¦å·
    if '\\' in path: #æ˜¯ä¸æ˜¯åæ–œæ ï¼Ÿ
        path = path.replace('\\','/') 
    if ('&' in path)|('<' in path)|('>' in path):
        path = path.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;') # aplha1.7.2 xml è½¬ç§»çš„bug
    if ('"' in path)|("'" in path):
        path = path.replace('"','&quot;').replace("'",'&apos;')
    if '//' in path:
        path = path.replace('//','/')
    # åˆ¤æ–­æ–‡ä»¶ç³»ç»Ÿ
    if path[0] == '/': #unix file system
        return 'file://localhost' + path
    elif (path[0].isalpha()) & (path[1]==':'): # windows disklabel
        path = path.replace(':','%3a') # æ›¿æ¢å†’å·
        return 'file://localhost/' + path
    else:
        raise ValueError('invalid path type')

# ä¼˜åŒ–å¯¼å‡ºPR clipçš„é€»è¾‘ï¼šæ˜¯å¦ä¸€å®šè¦åœ¨å°èŠ‚æ–­ç‚¹å¤„åˆ†æ®µï¼Ÿä¸åˆ†æ®µçš„è¯ä¼šæ€æ ·ï¼Ÿ

# å¤„ç†bg å’Œ am çš„parser
def parse_timeline(layer):
    global timeline,break_point
    break_at_breakpoint = ((layer[0:2]!='BG') & (layer[-1]!='S'))
    track = timeline[[layer]]
    clips = []
    item,begin,end = 'NA',0,0
    for key,values in track.iterrows():
        #å¦‚æœitemå˜åŒ–äº†ï¼Œæˆ–è€…è¿›å…¥äº†æŒ‡å®šçš„æ–­ç‚¹(ä»…æ–­ç‚¹åˆ†éš”çš„å›¾å±‚)
        if (values[layer] != item) | ((key in break_point.values) & break_at_breakpoint): 
            if (item == 'NA') | (item!=item): # å¦‚æœitmeæ˜¯ç©º 
                pass # åˆ™ä¸è¾“å‡ºä»€ä¹ˆ
            else:
                end = key #å¦åˆ™æŠŠå½“å‰keyä½œä¸ºä¸€ä¸ªclipçš„æ–­ç‚¹
                clips.append((item,begin,end)) #å¹¶è®°å½•ä¸‹è¿™ä¸ªæ–­ç‚¹
            item = values[layer] #æ— è®ºå¦‚ä½•ï¼Œé‡è®¾itemå’Œbegin
            begin = key
        else: #å¦‚æœä¸æ»¡è¶³æ–­ç‚¹è¦æ±‚ï¼Œé‚£ä¹ˆå°±ä»€ä¹ˆéƒ½ä¸åš
            pass
    # å¾ªç¯ç»“æŸä¹‹åï¼Œæœ€åæ£€å®šä¸€æ¬¡æ˜¯å¦éœ€è¦è¾“å‡ºä¸€ä¸ªclips
    #end = key # alpha 1.7.5 debug: å¾ªç¯ç»“æŸæ—¶çš„keyæœ‰å¯èƒ½å¹¶ä¸æ˜¯æ—¶é—´è½´çš„ç»ˆç‚¹
    end = int(break_point.max()) # å› ä¸ºæœ‰å¯èƒ½åˆ°ç»ˆç‚¹ä¸ºæ­¢ï¼Œæ‰€æœ‰å¸§éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè€Œå¯¼è‡´è¢«å»é‡ç•¥å»
    if (item == 'NA') | (item!=item):
        pass
    else:
        clips.append((item,begin,end))
    return clips #è¿”å›ä¸€ä¸ªclipçš„åˆ—è¡¨

# å¤„ç†Bb çš„parser
def parse_timeline_bubble(layer):
    global timeline,break_point
    break_at_breakpoint = ((layer[0:2]!='BG') & (layer[-1]!='S'))
    track = timeline[[layer,layer+'_main',layer+'_header']]
    clips = []
    item,begin,end = 'NA',0,0
    for key,values in track.iterrows():
        #å¦‚æœitemå˜åŒ–äº†ï¼Œæˆ–è€…è¿›å…¥äº†æŒ‡å®šçš„æ–­ç‚¹(è¿™æ˜¯ä¿è¯æ–­å¥çš„å…³é”®ï¼)(ä»…æ–­ç‚¹åˆ†éš”çš„å›¾å±‚)
        if (values[layer] != item) | ((key in break_point.values) & break_at_breakpoint): 
            if (item == 'NA') | (item!=item): # å¦‚æœitmeæ˜¯ç©º 
                pass # åˆ™ä¸è¾“å‡ºä»€ä¹ˆ
            else:
                end = key #å¦åˆ™æŠŠå½“å‰keyä½œä¸ºä¸€ä¸ªclipçš„æ–­ç‚¹
                clips.append((item,main_text,header_text,begin,end)) #å¹¶è®°å½•ä¸‹è¿™ä¸ªæ–­ç‚¹
            item = values[layer] #æ— è®ºå¦‚ä½•ï¼Œé‡è®¾itemå’Œbegin
            # main_text = values[layer + '_main'] # v 1.10.15 è¿™ä¸¤è¡Œä¼¼ä¹æ²¡å•¥ç”¨ï¼Ÿ
            # header_text = values[layer + '_header'] # å› ä¸ºä¸‹é¢åˆèµ‹å€¼äº†ä¸€é
            begin = key
        else: #å¦‚æœä¸æ»¡è¶³æ–­ç‚¹è¦æ±‚ï¼Œé‚£ä¹ˆå°±ä»€ä¹ˆéƒ½ä¸åš
            pass
        # ç„¶åæ›´æ–°æ–‡æœ¬å†…å®¹
        main_text = values[layer + '_main']
        header_text = values[layer + '_header']
    # å¾ªç¯ç»“æŸä¹‹åï¼Œæœ€åæ£€å®šä¸€æ¬¡æ˜¯å¦éœ€è¦è¾“å‡ºä¸€ä¸ªclips
    #end = key
    end = int(break_point.max()) # alpha 1.7.5 debug: è€Œbreakpointçš„æœ€å¤§å€¼ä¸€å®šæ˜¯æ—¶é—´è½´çš„ç»ˆç‚¹
    if (item == 'NA') | (item!=item):
        pass
    else:
        clips.append((item,main_text,header_text,begin,end))
    return clips #è¿”å›ä¸€ä¸ªclipçš„åˆ—è¡¨

# pygameå½¢å¼çš„posè½¬æ¢ä¸ºPRå½¢å¼çš„pos

def PR_center_arg(obj_size,pygame_pos):
    screensize = np.array(screen_size)
    return (pygame_pos+obj_size/2-screensize/2)/obj_size

# å…¨å±€å˜é‡

cmap = {'black':(0,0,0,255),'white':(255,255,255,255),'greenscreen':(0,177,64,255)}
Is_NTSC = str(frame_rate % 30 == 0)
Audio_type = 'Stereo'
stdin_name = stdin_log.replace('\\','/').split('/')[-1]
occupied_variable_name = open('./media/occupied_variable_name.list','r',encoding='utf8').read().split('\n')

# è½½å…¥xml æ¨¡æ¿æ–‡ä»¶

project_tplt = open('./xml_templates/tplt_sequence.xml','r',encoding='utf8').read()
track_tplt = open('./xml_templates/tplt_track.xml','r',encoding='utf8').read()
audio_track_tplt = open('./xml_templates/tplt_audiotrack.xml','r',encoding='utf8').read()
clip_tplt = open('./xml_templates/tplt_clip.xml','r',encoding='utf8').read()
audio_clip_tplt = open('./xml_templates/tplt_audio_clip.xml','r',encoding='utf8').read()

# è½½å…¥timeline å’Œ breakpoint

timeline_ifile = open(args.TimeLine,'rb')
timeline,break_point,bulitin_media = pickle.load(timeline_ifile)
timeline_ifile.close()

def main():
    global media_list
    print('[export XML]: Welcome to use exportXML for TRPG-replay-generator '+EDITION)
    print('[export XML]: The output xml file and refered png files will be saved at "'+output_path+'"')

    # è½½å…¥odæ–‡ä»¶
    try:
        object_define_text = open(media_obj,'r',encoding='utf-8').read()#.split('\n')
    except UnicodeDecodeError as E:
        print('[31m[DecodeError]:[0m',E)
        sys.exit(1)
    if object_define_text[0] == '\ufeff': # 139 debug
        print('[33m[warning]:[0m','UTF8 BOM recognized in MediaDef, it will be drop from the begin of file!')
        object_define_text = object_define_text[1:]
    object_define_text = object_define_text.split('\n')

    media_list=[]
    for i,text in enumerate(object_define_text):
        if text == '':
            continue
        elif text[0] == '#':
            continue
        else:
            try:
                exec(text) #å¯¹è±¡å®ä¾‹åŒ–
                obj_name = text.split('=')[0]
                obj_name = obj_name.replace(' ','')
                if obj_name in occupied_variable_name:
                    raise SyntaxError('Obj name occupied')
                elif (len(re.findall('\w+',obj_name))==0)|(obj_name[0].isdigit()):
                    raise SyntaxError('Invalid Obj name')
                media_list.append(obj_name) #è®°å½•æ–°å¢å¯¹è±¡åç§°
            except Exception as E:
                import traceback
                traceback.print_exc()
                print('[31m[SyntaxError]:[0m "'+text+'" appeared in media define file line ' + str(i+1)+' is invalid syntax:',E)
                sys.exit(1)
    black = Background('black')
    white = Background('white')
    media_list.append('black')
    media_list.append('white')
    # alpha 1.6.5 è½½å…¥å¯¼å‡ºçš„å†…å»ºåª’ä½“
    for key,values in bulitin_media.iteritems():
        exec(values)
        media_list.append(key)

    # å¼€å§‹ç”Ÿæˆ

    print('[export XML]: Begin to export.')
    video_tracks = []
    audio_tracks = []
    for layer in zorder + ['SE','Voice']:
        # æ°”æ³¡å›¾å±‚
        if layer[0:2] == 'Bb':
            track_items = parse_timeline_bubble(layer)
            bubble_clip_list = []
            text_clip_list = []
            for item in track_items:
                bubble_this,text_this = eval('{0}.display(begin ={1},end={2},text="{3}",header="{4}")'
                                             .format(item[0],item[3],item[4],item[1],item[2]))
                if bubble_this is not None:
                    # æ°”æ³¡çš„è¿”å›å€¼å¯èƒ½ä¸ºç©ºï¼
                    bubble_clip_list.append(bubble_this)
                # æ–‡æœ¬å§‹ç»ˆä¼šæœ‰ä¸€ä¸ªè¿”å›å€¼
                text_clip_list.append(text_this)
            video_tracks.append(track_tplt.format(**{'targeted':'False','clips':'\n'.join(bubble_clip_list)}))
            video_tracks.append(track_tplt.format(**{'targeted':'True','clips':'\n'.join(text_clip_list)}))
        # éŸ³æ•ˆå›¾å±‚
        elif layer in ['SE','Voice']:
            track_items = parse_timeline(layer)
            clip_list = []
            for item in track_items:
                if item[0] in media_list:
                    clip_list.append(eval('{0}.display(begin={1})'.format(item[0],item[1])))
                elif os.path.isfile(item[0][1:-1]) == True: # æ³¨æ„è¿™ä¸ªä½ç½®çš„item[0]é¦–å°¾åº”è¯¥æœ‰ä¸ªå¼•å·
                    temp = Audio(item[0][1:-1])
                    clip_list.append(temp.display(begin=item[1]))
                else:
                    print("[33m[warning]:[0m",'Audio file',item[0],'is not exist.')
            audio_tracks.append(audio_track_tplt.format(**{'type':Audio_type,'clips':'\n'.join(clip_list)}))
        # ç«‹ç»˜æˆ–è€…èƒŒæ™¯å›¾å±‚
        else:
            track_items = parse_timeline(layer)
            clip_list = []
            for item in track_items:
                clip_list.append(eval('{0}.display(begin={1},end={2})'.format(item[0],item[1],item[2])))
            video_tracks.append(track_tplt.format(**{'targeted':'False','clips':'\n'.join(clip_list)}))

    main_output = project_tplt.format(**{'timebase':'%d'%frame_rate,
                           'ntsc':Is_NTSC,
                           'sequence_name':stdin_name,
                           'screen_width':'%d'%screen_size[0],
                           'screen_height':'%d'%screen_size[1],
                           'tracks_vedio':'\n'.join(video_tracks),
                           'tracks_audio':'\n'.join(audio_tracks)})

    ofile = open(output_path+'/'+stdin_name+'.xml','w',encoding='utf-8')
    ofile.write(main_output)
    ofile.close()
    print('[export XML]: Done! XML path : '+output_path+'/'+stdin_name+'.xml')
if __name__ == '__main__':
    main()