#!/usr/bin/env python
# coding: utf-8
edtion = 'alpha 1.6.6'

# å¤–éƒ¨å‚æ•°è¾“å…¥

import argparse
import sys
import os

ap = argparse.ArgumentParser(description="Export MP4 video from timeline file.")
ap.add_argument("-l", "--TimeLine", help='Timeline (and break_point with same name), which was generated by replay_generator.py.',type=str)
ap.add_argument("-d", "--MediaObjDefine", help='Definition of the media elements, using real python code.',type=str)
ap.add_argument("-t", "--CharacterTable", help='This program do not need CharacterTable.',type=str)
ap.add_argument("-o", "--OutputPath", help='Choose the destination directory to save the project timeline and break_point file.',type=str,default=None)
# å¢åŠ ä¸€ä¸ªï¼Œè¯»å–æ—¶é—´è½´å’Œæ–­ç‚¹æ–‡ä»¶çš„é€‰é¡¹ï¼
ap.add_argument("-F", "--FramePerSecond", help='Set the FPS of display, default is 30 fps, larger than this may cause lag.',type=int,default=30)
ap.add_argument("-W", "--Width", help='Set the resolution of display, default is 1920, larger than this may cause lag.',type=int,default=1920)
ap.add_argument("-H", "--Height", help='Set the resolution of display, default is 1080, larger than this may cause lag.',type=int,default=1080)
ap.add_argument("-Z", "--Zorder", help='Set the display order of layers, not recommended to change the values unless necessary!',type=str,
                default='BG3,BG2,BG1,Am3,Am2,Am1,Bb')
args = ap.parse_args()

media_obj = args.MediaObjDefine #åª’ä½“å¯¹è±¡å®šä¹‰æ–‡ä»¶çš„è·¯å¾„
char_tab = args.CharacterTable #è§’è‰²å’Œåª’ä½“å¯¹è±¡çš„å¯¹åº”å…³ç³»æ–‡ä»¶çš„è·¯å¾„
stdin_log = args.TimeLine #logè·¯å¾„
output_path = args.OutputPath #ä¿å­˜çš„æ—¶é—´è½´ï¼Œæ–­ç‚¹æ–‡ä»¶çš„ç›®å½•

screen_size = (args.Width,args.Height) #æ˜¾ç¤ºçš„åˆ†è¾¨ç‡
frame_rate = args.FramePerSecond #å¸§ç‡ å•ä½fps
zorder = args.Zorder.split(',') #æ¸²æŸ“å›¾å±‚é¡ºåº

try:
    for path in [stdin_log,media_obj]:
        if path == None:
            print(path)
            raise OSError("[31m[ArgumentError]:[0m Missing principal input argument!")
        if os.path.isfile(path) == False:
            raise OSError("[31m[ArgumentError]:[0m Cannot find file "+path)

    if output_path == None:
        pass 
    elif os.path.isdir(output_path) == False:
        try:
            os.makedirs(output_path)
        except:
            raise OSError("[31m[SystemError]:[0m Cannot make directory "+output_path)
    output_path = output_path.replace('\\','/')

    # FPS
    if frame_rate <= 0:
        raise ValueError("[31m[ArgumentError]:[0m "+str(frame_rate))
    elif frame_rate>30:
        print("[33m[warning]:[0m",'FPS is set to '+str(frame_rate)+', which may cause lag in the display!')

    if (screen_size[0]<=0) | (screen_size[1]<=0):
        raise ValueError("[31m[ArgumentError]:[0m "+str(screen_size))
    if screen_size[0]*screen_size[1] > 3e6:
        print("[33m[warning]:[0m",'Resolution is set to more than 3M, which may cause lag in the display!')
except Exception as E:
    print(E)
    sys.exit()

import pandas as pd
import numpy as np
import pygame
import ffmpeg
import pydub
import time
import glob # åŒ¹é…è·¯å¾„

# æ–‡å­—å¯¹è±¡
class Text:
    pygame.font.init()
    def __init__(self,fontfile='C:/Windows/Fonts/simhei.ttf',fontsize=40,color=(0,0,0,255),line_limit=20):
        self.text_render = pygame.font.Font(fontfile,fontsize)
        self.color=color
        self.size=fontsize
        self.line_limit = line_limit
    def draw(self,text):
        out_text = []
        if ('#' in text) | (text[0]=='^'): #å¦‚æœæœ‰æ‰‹åŠ¨æŒ‡å®šçš„æ¢è¡Œç¬¦ # bug:å¦‚æœæ‰‹åŠ¨æ¢è¡Œï¼Œä½†æ˜¯ç¬¬ä¸€ä¸ª#åœ¨30å­—ä»¥å¤–ï¼Œå¼‚å¸¸çš„æ˜¾ç¤º
            if text[0]=='^': # å¦‚æœä½¿ç”¨^æŒ‡å®šçš„æ‰‹åŠ¨æ¢è¡Œï¼Œåˆ™å…ˆå»æ‰è¿™ä¸ªå­—ç¬¦ã€‚
                text = text[1:]
            text_line = text.split('#')
            for tx in text_line:
                out_text.append(self.text_render.render(tx,True,self.color))
        elif len(text) > self.line_limit: #å¦‚æœæ—¢æ²¡æœ‰ä¸»åŠ¨æŒ‡å®šï¼Œå­—ç¬¦é•¿åº¦ä¹Ÿè¶…é™
            for i in range(0,len(text)//self.line_limit+1):#è¾ƒä¸ºç®€å•ç²—æš´çš„è‡ªåŠ¨æ¢è¡Œ
                out_text.append(self.text_render.render(text[i*self.line_limit:(i+1)*self.line_limit],True,self.color))
        else:
            out_text = [self.text_render.render(text,True,self.color)]
        return out_text
    def convert(self):
        pass

# å¯¹è¯æ¡†ã€æ°”æ³¡ã€æ–‡æœ¬æ¡†
class Bubble:
    def __init__(self,filepath,Main_Text=Text(),Header_Text=None,pos=(0,0),mt_pos=(0,0),ht_pos=(0,0),line_distance=1.5):
        self.media = pygame.image.load(filepath)
        self.pos = pos
        self.MainText = Main_Text
        self.mt_pos = mt_pos
        self.Header = Header_Text
        self.ht_pos = ht_pos
        self.line_distance = line_distance
    def display(self,surface,text,header='',alpha=100,adjust='NA'):
        if adjust in ['0,0','NA']:
            render_pos = self.pos
        else:
            adx,ady = split_xy(adjust)
            render_pos = (self.pos[0]+adx,self.pos[1]+ady)
        temp = self.media.copy()
        if (self.Header!=None) & (header!=''):    # Header æœ‰å®šä¹‰ï¼Œä¸”è¾“å…¥æ–‡æœ¬ä¸ä¸ºç©º
            temp.blit(self.Header.draw(header)[0],self.ht_pos)
        x,y = self.mt_pos
        for i,s in enumerate(self.MainText.draw(text)):
            temp.blit(s,(x,y+i*self.MainText.size*self.line_distance))
        if alpha !=100:
            temp.set_alpha(alpha/100*255)            
        surface.blit(temp,render_pos)
    def convert(self):
        self.media = self.media.convert_alpha()

# èƒŒæ™¯å›¾ç‰‡
class Background:
    def __init__(self,filepath,pos = (0,0)):
        if filepath in cmap.keys(): #æ·»åŠ äº†ï¼Œå¯¹çº¯è‰²å®šä¹‰çš„èƒŒæ™¯çš„æ”¯æŒ
            self.media = pygame.surface.Surface(screen_size)
            self.media.fill(cmap[filepath])
        else:
            self.media = pygame.image.load(filepath)
        self.pos = pos
    def display(self,surface,alpha=100,adjust='NA'):
        if adjust in ['0,0','NA']:
            render_pos = self.pos
        else:
            adx,ady = split_xy(adjust)
            render_pos = (self.pos[0]+adx,self.pos[1]+ady)
        if alpha !=100:
            temp = self.media.copy()
            temp.set_alpha(alpha/100*255)
            surface.blit(temp,render_pos)
        else:
            surface.blit(self.media,render_pos)
    def convert(self):
        self.media = self.media.convert_alpha()

# è¿™ä¸ªæ˜¯çœŸçš„åŠ¨ç”»äº†ï¼Œç”¨æ³•å’Œæ—§ç‰ˆçš„aminationæ˜¯ä¸€æ ·çš„ï¼
class Animation:
    def __init__(self,filepath,pos = (0,0),tick=1,loop=True):
        file_list = np.frompyfunc(lambda x:x.replace('\\','/'),1,1)(glob.glob(filepath))
        self.length = len(file_list)
        if self.length == 0:
            raise IOError('[31m[IOError]:[0m','Cannot find file match',filepath)
        self.media = np.frompyfunc(pygame.image.load,1,1)(file_list)
        self.pos = pos
        self.loop = loop
        self.this = 0
        self.tick = tick
    def display(self,surface,alpha=100,adjust='NA',frame=0):
        self.this = frame
        if adjust in ['0,0','NA']:
            render_pos = self.pos
        else:
            adx,ady = split_xy(adjust)
            render_pos = (self.pos[0]+adx,self.pos[1]+ady)
        if alpha !=100:
            temp = self.media[int(self.this)].copy()
            temp.set_alpha(alpha/100*255)
            surface.blit(temp,render_pos)
        else:
            surface.blit(self.media[int(self.this)],render_pos)
        #self.this = self.this + 1/self.tick
        #if self.this >= self.length - 1: # åœ¨timeline ç®€å¹¶ ä¹‹åä¼šå‡ºç°bugï¼
        #    if self.loop == True:
        #        self.this = 0
        #    else:
        #        self.this = self.length - 1
    def convert(self):
        self.media = np.frompyfunc(lambda x:x.convert_alpha(),1,1)(self.media)

# a1.6.5 å†…å»ºåŠ¨ç”»ï¼Œè¿™æ˜¯ä¸€ä¸ªAnimationç±»çš„å­ç±»ï¼Œé‡æ„äº†æ„é€ å‡½æ•°
class BuiltInAnimation(Animation):
    def __init__(self,anime_type='hitpoint',anime_args=('0',0,0,0),screensize = (1920,1080),layer=0):
        if anime_type == 'hitpoint':
            # è½½å…¥å›¾ç‰‡
            heart = pygame.image.load('./media/heart.png')
            heart_shape = pygame.image.load('./media/heart_shape.png')
            hx,hy = heart.get_size()
            # é‡è®¾å›¾ç‰‡å°ºå¯¸ï¼Œæ ¹æ®screensize[0]
            if screensize[0]!=1920:
                multip = screensize[0]/1920
                heart = pygame.transform.scale(heart,(int(hx*multip),int(hy*multip)))
                heart_shape = pygame.transform.scale(heart_shape,(int(hx*multip),int(hy*multip)))
                hx,hy = heart.media[0].get_size()
            # åŠ¨ç”»å‚æ•°
            name_tx,heart_max,heart_begin,heart_end = anime_args

            if (heart_end==heart_begin)|(heart_max<max(heart_begin,heart_end)):
                raise ValueError('[BIAnimeError]:','Invalid argument',name_tx,heart_max,heart_begin,heart_end,'for BIAnime hitpoint!')
            elif heart_end > heart_begin: # å¦‚æœæ˜¯ç”Ÿå‘½æ¢å¤
                temp = heart_end
                heart_end = heart_begin
                heart_begin = temp # åˆ™äº’æ¢é¡ºåº ç¡®ä¿ beginä¸€å®šæ˜¯å°äºendçš„
                heal_heart = True
            else:
                heal_heart = False

            distance = int(0.026*screensize[0]) # default = 50

            total_heart = int(heart_max/2 * hx + max(0,np.ceil(heart_max/2-1)) * distance) #ç”»å¸ƒæ€»é•¿
            left_heart = int(heart_end/2 * hx + max(0,np.ceil(heart_end/2-1)) * distance) #ç”»å¸ƒæ€»é•¿
            lost_heart = int((heart_begin-heart_end)/2 * hx + np.floor((heart_begin-heart_end)/2) * distance)
            # å¼€å§‹åˆ¶å›¾
            if layer==0: # åº•å±‚ é˜´å½±å›¾
                self.pos = ((screensize[0]-total_heart)/2,(screensize[1]-hy)/2)
                canvas = pygame.Surface((total_heart,hy),pygame.SRCALPHA)
                canvas.fill((0,0,0,0))
                posx,posy = 0,0
                self.tick = 1
                self.loop = 1
                for i in range(1,heart_max+1): # å¶æ•°ï¼Œä½äºæœ€ç»ˆè¡€é‡
                    if i%2 == 0:
                        canvas.blit(heart_shape,(posx,posy))
                        posx = posx + hx + distance
                    else:
                        pass
                if heart_max%2 == 1: # maxæ˜¯å¥‡æ•°
                    left_heart_shape = heart_shape.subsurface((0,0,int(hx/2),hy))
                    canvas.blit(left_heart_shape,(total_heart-int(hx/2),0))
            if layer==1: # å‰©ä½™çš„è¡€é‡
                self.pos = ((screensize[0]-total_heart)/2,(screensize[1]-hy)/2)
                canvas = pygame.Surface((left_heart,hy),pygame.SRCALPHA)
                canvas.fill((0,0,0,0))
                posx,posy = 0,0
                self.tick = 1
                self.loop = 1
                for i in range(1,heart_end+1): # å¶æ•°ï¼Œä½äºæœ€ç»ˆè¡€é‡
                    if i%2 == 0:
                        canvas.blit(heart,(posx,posy))
                        posx = posx + hx + distance
                    else:
                        pass
                if heart_end%2 == 1: # endæ˜¯å¥‡æ•°
                    left_heart = heart.subsurface((0,0,int(hx/2),hy))
                    canvas.blit(left_heart,(heart_end//2*(hx + distance),0))
            elif layer==2: # æŸå¤±/æ¢å¤çš„è¡€é‡
                self.pos = (heart_end//2*(hx + distance)+(heart_end%2)*int(hx/2)+(screensize[0]-total_heart)/2,(screensize[1]-hy)/2)
                canvas = pygame.Surface((lost_heart,hy),pygame.SRCALPHA)
                canvas.fill((0,0,0,0))
                posx,posy = 0,0
                self.tick = 1
                self.loop = 1
                for i in range(1,heart_begin-heart_end+1): 
                    if (i == 1)&(heart_end%2 == 1): # å¦‚æœendæ˜¯å¥‡æ•°ï¼Œå…ˆæ¥åŠä¸ªå³è¾¹
                        right_heart = heart.subsurface((int(hx/2),0,int(hx/2),hy))
                        canvas.blit(right_heart,(posx,posy))
                        posx = posx + int(hx/2) + distance
                    elif ((i - heart_end%2)%2 == 0): # å¦‚æœå’Œendçš„å·®å€¼æ˜¯
                        canvas.blit(heart,(posx,posy))
                        posx = posx + hx + distance
                    elif (i == heart_begin-heart_end)&(heart_begin%2 == 1): # å¦‚æœæœ€å³è¾¹è¾¹ä¹Ÿæ˜¯åŠä¸ªå¿ƒ
                        left_heart = heart.subsurface((0,0,int(hx/2),hy))
                        canvas.blit(left_heart,(posx,posy))
                    else:
                        pass
            else:
                pass
            if (heal_heart == True)&(layer == 2): # æ¢å¤åŠ¨ç”»
                crop_timeline = sigmoid(0,lost_heart,frame_rate).astype(int)
                self.media = np.frompyfunc(lambda x:canvas.subsurface(0,0,x,hy),1,1)(crop_timeline) # è£å‰ªåŠ¨ç”»
            else:
                self.media=np.array([canvas])
            #å‰©ä¸‹çš„éœ€è¦å®šä¹‰çš„
            self.this = 0
            self.length=len(self.media)

# éŸ³æ•ˆ
class Audio:
    def __init__(self,filepath):
        self.media = pydub.AudioSegment.from_file(filepath)
    def convert(self):
        pass

# èƒŒæ™¯éŸ³ä¹
class BGM:
    def __init__(self,filepath,volume=100,loop=True):
        self.media = pydub.AudioSegment.from_file(filepath) + np.log10(volume/100) * 20 # è°ƒæ•´éŸ³é‡
        self.loop = loop
    def convert(self):
        pass

# å¤„ç†bg å’Œ am çš„parser
def parse_timeline(layer):
    global timeline,break_point
    track = render_timeline[[layer]]
    clips = []
    item,begin,end = 'NA',0,0
    for key,values in track.iterrows():
        #å¦‚æœitemå˜åŒ–äº†ï¼Œæˆ–è€…è¿›å…¥äº†æŒ‡å®šçš„æ–­ç‚¹
        if (values[layer] != item) | (key in break_point.values): 
            if (item == 'NA') | (item!=item): # å¦‚æœitmeæ˜¯ç©º 
                pass # åˆ™ä¸è¾“å‡ºä»€ä¹ˆ
            else:
                end = key #å¦åˆ™æŠŠå½“å‰keyä½œä¸ºä¸€ä¸ªclipçš„æ–­ç‚¹
                clips.append((item,begin,end)) #å¹¶è®°å½•ä¸‹è¿™ä¸ªæ–­ç‚¹
            item = values[layer] #æ— è®ºå¦‚ä½•ï¼Œé‡è®¾itemå’Œbegin
            begin = key
        else: #å¦‚æœä¸æ»¡è¶³æ–­ç‚¹è¦æ±‚ï¼Œé‚£ä¹ˆå°±ä»€ä¹ˆéƒ½ä¸åš
            pass
    # å¾ªç¯ç»“æŸä¹‹åï¼Œæœ€åæ£€å®šä¸€æ¬¡æ˜¯å¦éœ€è¦è¾“å‡ºä¸€ä¸ªclips
    end = key
    if (item == 'NA') | (item!=item):
        pass
    else:
        clips.append((item,begin,end))
    return clips #è¿”å›ä¸€ä¸ªclipçš„åˆ—è¡¨

def normalized(X):
    if len(X)>=2:
        return (X-X.min())/(X.max()-X.min())
    else:
        return X/X # å…¼å®¹ æŒç»­æ—¶é—´è¢«è®¾ç½®ä¸º0ï¼Œ1ç­‰æé™æƒ…å†µ

def sigmoid(begin,end,dur,K=5):
    return normalized(1/(1+np.exp(np.linspace(K,-K,int(dur)))))*(end-begin)+begin

def split_xy(concated):
    x,y = concated.split(',')
    return int(x),int(y)

def render(this_frame):
    global zorder,media_list
    for layer in zorder:
        # ä¸æ¸²æŸ“çš„æ¡ä»¶ï¼šå›¾å±‚ä¸º"Na"ï¼Œæˆ–è€…np.nan
        if (this_frame[layer]=='NA')|(this_frame[layer]!=this_frame[layer]):
            continue
        elif this_frame[layer+'_a']<=0: #æˆ–è€…å›¾å±‚çš„é€æ˜åº¦å°äºç­‰äº0(ç”±äºfillna("NA"),å‡ºç°çš„å¼‚å¸¸)
            continue
        elif this_frame[layer] not in media_list:
            raise RuntimeError('[31m[RenderError]:[0m Undefined media object : ['+this_frame[layer]+'].')
            continue
        elif layer[0:2] == 'BG':
            exec('{0}.display(surface=screen,alpha={1},adjust={2})'.format(this_frame[layer],this_frame[layer+'_a'],'\"'+this_frame[layer+'_p']+'\"'))
        elif layer[0:2] == 'Am': # å…¼å®¹H_LG1(1)è¿™ç§åŠ¨ç”»å½¢å¼ alpha1.6.3
            exec('{0}.display(surface=screen,alpha={1},adjust={2},frame={3})'.format(
                                                                                     this_frame[layer],
                                                                                     this_frame[layer+'_a'],
                                                                                     '\"'+this_frame[layer+'_p']+'\"',
                                                                                     this_frame[layer+'_t']))
        elif layer == 'Bb':
            exec('{0}.display(surface=screen,text={2},header={3},alpha={1},adjust={4})'.format(this_frame[layer],
                                                                                               this_frame[layer+'_a'],
                                                                                               '\"'+this_frame[layer+'_main']+'\"',
                                                                                               '\"'+this_frame[layer+'_header']+'\"',
                                                                                               '\"'+this_frame[layer+'_p']+'\"'))
    return 1


# è½½å…¥timeline å’Œ breakpoint

render_timeline = pd.read_pickle(stdin_log)
break_point = pd.read_pickle(stdin_log.replace('timeline','breakpoint'))
stdin_name = stdin_log.replace('\\','/').split('/')[-1]
bulitin_media = pd.read_pickle(stdin_log.replace('timeline','bulitinmedia'))

cmap = {'black':(0,0,0,255),'white':(255,255,255,255),'greenscreen':(0,177,64,255)}

# è½½å…¥odæ–‡ä»¶
print('[export Video]: Welcome to use exportVideo for TRPG-replay-generator '+edtion)
print('[export Video]: The output mp4 file will be saved at "'+output_path+'"')

# è½½å…¥odæ–‡ä»¶
object_define_text = open(media_obj,'r',encoding='utf-8').read().split('\n')

media_list=[]
for i,text in enumerate(object_define_text):
    if text == '':
        continue
    elif text[0] == '#':
        continue
    else:
        try:
            exec(text) #å¯¹è±¡å®ä¾‹åŒ–
            obj_name = text.split('=')[0]
            obj_name = obj_name.replace(' ','')
            media_list.append(obj_name) #è®°å½•æ–°å¢å¯¹è±¡åç§°
        except Exception as E:
            print('[31m[SyntaxError]:[0m "'+text+'" appeared in media define file line ' + str(i+1)+' is invalid syntax:',E)
            sys.exit()
black = Background('black')
white = Background('white')
media_list.append('black')
media_list.append('white')
# alpha 1.6.5 è½½å…¥å¯¼å‡ºçš„å†…å»ºåª’ä½“
for key,values in bulitin_media.iteritems():
    exec(values)
    media_list.append(key)

# åˆæˆéŸ³è½¨

print('[export Video]: Start mixing audio tracks')

tracks = ['SE','Voice','BGM']
main_Track = pydub.AudioSegment.silent(duration=int(break_point.values.max()/frame_rate*1000),frame_rate=16000) # ä¸»è½¨é“

for tr in tracks:
    this_Track = pydub.AudioSegment.silent(duration=int(break_point.values.max()/frame_rate*1000),frame_rate=16000)
    if tr == 'BGM':
        BGM_clips = parse_timeline('BGM')
        for i,item in enumerate(BGM_clips):
            voice,begin,drop = item
            if voice == 'stop':
                continue # é‡åˆ°stopï¼Œç›´åˆ‡åˆ‡åˆ°ä¸‹ä¸€æ®µ
            elif voice not in media_list: # å¦‚æœæ˜¯è·¯å¾„å½¢å¼
                temp_BGM = BGM(voice[1:-1]) # å»é™¤å¼•å·
                voice = 'temp_BGM'
            try:
                end = BGM_clips[i+1][1]
            except IndexError:
                end = break_point.values.max()
            #print(begin,end)
            this_Track = this_Track.overlay(pydub.AudioSegment.silent(duration=int((end-begin)/frame_rate*1000),
                                                              frame_rate=16000).overlay(eval(voice+'.media')
                                                                                        ,loop=True),
                                    position = int(begin/frame_rate*1000))
    else:
        for item in parse_timeline(tr):
            voice,begin,drop = item
            if voice not in media_list: # å¦‚æœæ˜¯è·¯å¾„å½¢å¼
                temp_AU = Audio(voice[1:-1]) # å»é™¤å¼•å·
                voice = 'temp_AU'
            this_Track = this_Track.overlay(eval(voice+'.media'),position = int(begin/frame_rate*1000))
    main_Track = main_Track.overlay(this_Track) #åˆæˆåˆ°ä¸»éŸ³è½¨

main_Track.export(output_path+'/'+stdin_name+'.mp3',format='mp3',codec='mp3')

print('[export Video]: Audio mixing done!')

# åˆå§‹åŒ–

print('[export Video]: Start encoding video, using ffmpeg.')

pygame.init()
screen = pygame.display.set_mode(screen_size,pygame.HIDDEN)

# è½¬æ¢åª’ä½“å¯¹è±¡
for media in media_list: 
    try:
        exec(media+'.convert()')
    except Exception as E:
        print('[31m[MediaError]:[0m Exception during converting',media,':',E)
        sys.exit()

# ffmpegè¾“å‡º
output_engine = (
    ffmpeg
    .input('pipe:',format='rawvideo',r=frame_rate,pix_fmt='rgb24', s='{0}x{1}'.format(screen_size[1],screen_size[0])) # è§†é¢‘æ¥æº
    .output(ffmpeg.input(output_path+'/'+stdin_name+'.mp3').audio,
            output_path+'/'+stdin_name+'.mp4',
            pix_fmt='yuv420p',r=frame_rate,crf=24,
            **{'loglevel':'quiet','vf':'transpose=0'}) # è¾“å‡º
    .overwrite_output()
    .run_async(pipe_stdin=True)
)

begin_time = time.time()
# ä¸»å¾ªç¯
n=0
while n < break_point.max():
    try:
        if n in render_timeline.index:
            this_frame = render_timeline.loc[n]
            render(this_frame)
            obyte = pygame.surfarray.array3d(screen).tobytes()
        else:
            pass # èŠ‚çº¦ç®—åŠ›
        output_engine.stdin.write(obyte) # å†™å…¥è§†é¢‘
        n = n + 1 #ä¸‹ä¸€å¸§
    except Exception as E:
        print(E)
        output_engine.stdin.close()
        pygame.quit()
        sys.exit()
    if n%frame_rate == 1:
        finish_rate = n/break_point.values.max()
        print('[export Video]:','[{0}] {1},\t{2}'.format(int(finish_rate*50)*'#'+(50-int(50*finish_rate))*' ',
                                                        '%.1f'%(finish_rate*100)+'%','{0}/{1}'.format(n,'%d'%break_point.values.max())),
        end = "\r"
        )
    elif n == break_point.values.max():
        print('[export Video]:','[{0}] {1},\t{2}'.format(50*'#',
                                                        '%.1f'%100+'%','{0}/{1}'.format(n,n)))
output_engine.stdin.close()
pygame.quit()

used_time = time.time()-begin_time

print('[export Video]: Export time elapsed : '+time.strftime("%H:%M:%S", time.gmtime(used_time)))
print('[export Video]: Mean frames rendered per second : '+'%.2f'%(break_point.max()/used_time)+' FPS')
print('[export Video]: Encoding finished! Video path :',output_path+'/'+stdin_name+'.mp4')

sys.exit()
